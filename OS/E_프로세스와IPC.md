# 프로세스와 IPC

> IPC가 필요한 이유를 프로세스의 구조로 이해한다.



### A. 프로세스 공간

운영체제의 실제 프로세스간 공간은 완전히 분리되어 있다. **사용자 모드에서 커널 공간엔 접근할 수 없다.**

![프로세스공간1](./images/p_structure1.png)

- 하나의 프로세스의 크기가 4Gb로 정해져 있을 때, 내 컴퓨터의 메모리는 16Gb이다. 그렇다면 어떻게 동시에 여러 개(4개 이상)의 프로그램을 돌릴 수 있는 것일까? 가상 주소를 사용하기 때문에 가능하다. 실제 물리 메모리에 있는 공간과 다른 가상 주소를 사용하는데, 이는 가상 메모리 강의에서 배움

- 어떤 프로세스든 지정할 수 있는 주소는 0번부터 4Gb까지라는 점과 3Gb~4Gb에는 운영체제 코드가 0 ~ 3Gb에는 실제 프로그래머가 작성한 프로그램들이 사용하는 영역이다.


![프로세스공간2](./images/p_structure2.png)


주소 공간을 모두 사용하는 것이 아니라, 일부분만 사용한다. 그 중 아주 작은 부분만 실제 물리 메모리에 올라가므로 여러 개의 프로그램을 돌리는데 문제가 되지 않는다.

그렇다면 여러 개의 프로그램을 돌릴 때, 각 프로세스마다 운영체제 코드가 따로 존재한다면 공간의 낭비이다. 그래서 각 프로세스의 커널 부분은(운영체제 코드) 실제 물리 메모리에 올라갈 때, 동일한 공간을 공유한다. 즉, **프로세스들은 커널 공간을 공유한다.**



### B. IPC : InterProcess Communication

다양한 IPC 기법(프로세스간 커뮤니케이션)이 존재한다.

1. file 사용 : 실시간성 떨어짐, 저장매체를 다녀오는 것이므 시간이 오래걸림
2. Message Queue
3. Shared Memory
4. Pipe
5. Signal
6. Semaphore
7. Socket

> 2번 ~ 8번 기법은 모두 커널공간(이미 물리 메모리에 올라와 있는 것)을 이용하는 것이므로, 저장매체인 file을 엑세스하는 것보다 빠르며 프로세스 간 공유가 가능하다는 장점이 있다. 즉, **IPC는 커널 공간을 어떻게 활용할 것인가**가 핵심이다.



**[정리] IPC가 필요한 이유**

1. 여러 프로세스를 동시에 실행할 때, 병렬처리를 해야 속도가 빨라진다. 그러나 병렬처리를 하더라도 프로세스간 통신이 필요한 부분들이 있다. 그렇다고 프로세스A가 프로세스B의 코드나 데이터에 직접 접근할 수 있다면 큰 문제가 생길수 있으므 별도의 커뮤니케이션 방법을 제공해야 한다.
2. 프로세스 공간은 완전히 분리되어 있다. 해커들이 만든 프로그램이 강제로 다른 프로그램에 접근하는 것을 막기 위해 최대한 분리해둠
3. 즉, 프로세스간 통신을 위한 특별한 기법이 필요하다. 이것이 IPC 기법이다.
4. 대부분 IPC 기법의 핵심은 커널 공간을 활용하는 것이다. 프로세스간 커널 공간은 공유하기 때문이다.



## I. 다양한 IPC 기법

> 각 IPC 기법의 장단점을 간단히 이해하고 넘어가기



### 1. 파이프(Pipe)

![ipc_pipe](./images/ipc_pipe.png)

- 기본 파이프는 단반향 통신, 부모의 값을 자식에게 전달

- fork()라는 시스템콜로 자식 프로세스를 만들 때, 부모와 자식간의 통신이 가능

  > **fork**는 시스템콜 중에 하나로, 현재 실행중인 프로세스의 코드를 복사하여 새로운 프로세스를 생성하고 PC가 바로 다음 위치를 가리키게 한다. 이때, 원본을 부모 프로세스, 복사본은 자식 프로세스라고 한다.

  > 그렇다면, 왜 같은 코드와 데이터를 가지는 프로세스를 하나 더 생성하는 가? 하나의 프로세스에서 동시에 두 가지 작업을 수행해야할 때, Pid를 조건문으로 분기시켜 사용한다. (자식 프로세스의 pid는 0으로 생성된다.)

```c
char* msg = "Hello Child Process!"; 
int main()
{
  char buf[255];
  int fd[2], pid, nbytes;
  if (pipe(fd) < 0)
		exit(1);
	pid = fork();	// fork() 함수를 사용하면 부모/자식 프로세스로 나눠짐
  if(pid>0){	// 부모 프로세스에는 실제 PID가 들어감
    pid write(fd[1], msg, MSGSIZE);	// write시스템 콜을 이용해 msg를 쓴다.
    exit(0);
  }
	else{ //	pid 0 : 자식 프로세스의 PID는 0이다.
		nbytes = read(fd[0], buf, MSGSIZE); // buf에는 부모 프로세스의 msg가 넘어온다!
    printf("%d %s\n", nbytes, buf);
		exit(0);
	}
	return 0; 
}
```



### 2. 메시지 큐(Message Queue)

![Message Queue](./images/message_queue.png)

- FIFO 정책으로 프로세스A에서 프로세스B로 데이터를 전송
- 메시지 큐는 부모/자식이 아니라, 어느 프로세스간에도 데이터 송수신이 가능하다.

```c
// 프로세스A
msqid=msgget(key, msgflg)	// key = 1234
msgsnd(msqid, &sbuf, buf_length, IPC_NOWAIT)	// 데이터가 메시지큐에 들어감
```

```c
// 프로세스B
msqid = msgget(key, msgflg)	// key값을 동일하게 1234로 해야 해당 큐의 id를 얻을 수 있다.
msgrcv(msqid, &rbuf, MSGSZ, 1, 0)	// 해당 메시지큐의 데이터를 하나씩 꺼낸다.
```



>**파이프와 메시지 큐**
>
>![파이프와 메시지 큐](./images/pipe_message_queue.png)
>
>- 파이프와 메시지 큐 모두 커널 공간의 메모리를 사용한다.



### 3. 공유 메모리(Shared Memory)

![Shared Memory](./images/shared_memory.png)

- 노골적으로 커널 공간에 메모리 공간을 만들고 해당 공간을 변수처럼 사용하는 방식
- 공유 메모리 key를 가지고 여러 프로세스가 접근이 가능하다.

```c
// [1] 공유 메모리 생성 및 공유 메모리 주소 얻기
shmid = shmget((key_t)1234, SIZE, IPC_CREAT|0666))
shmaddr = shmat(shmid, (void *)0, 0)

// [2] 공유 메모리에 쓰기
strcpy((char *)shmaddr, "Linux Programming")
  
// [3] 공유 메모리 읽기
printf("%s\n", (char *)shmaddr)
```

