# JVM, 변수와 타입


- OOP(Object Oriented Language) : 객체지향 언어이다.

- 플랫폼에 독립적이다.
  
  
  - JVM만 있으면 윈도우, 리눅스, 맥 등 어떤 플랫폼에서도 실행이 가능하다.

  ```shell
  # src/HelloWorld.java		  // java 소스코드
  $javac HelloWorld.java		// java 컴파일
  
  # bin/HelloWorld.class 	  // 컴파일된 class 파일(바이트 코드) 
  # JVM은 컴파일된 바이트 코드를 os에 맞게 실행시킴
  # 즉, 비이트 코드(.class)는 JVM이 설치된 어느 OS에서나 사용이 가능하다.
  $java HelloWorld.class   // java 실행하기
  ```

- 가비지 컬렉터가 메모리 관리를 자동으로 해준다.



## I. 자바 가상 머신(JVM)

1. 자바 인터프리터

   - 컴파일러에 의에 번역된 자바 바이트 코드를 읽고 해석하는 역할

2. 클래스 로더

   - 자바는 동적으로 클래스를 읽어오므로, 프로그램 실행 중인 런타임에서야 모든 코드가 자바 가상머신과 연결됨
   - 동적으로 클래스를 로딩해주는 역할

3. **JIT 컴파일러(just-In-Time compiler)**

   - 실행 중인 런타임에 실제 기계어로 변환해 주는 컴파일러를 의미

   - 동적번역(dynamic translaiton)이라고 불리는 이 기법은 프로그램의 실행속도를 향상시키기 위해 개발됨. 즉, 자바의 성능과 연관된다.

   - 핫스팟 컴파일

     - 일반적인 프로그램에서 전체 코드 중 일부만 자주 실행되며 어플리케이션의 성능은 이 영역(핫스팟)의 코드가 얼마나 빠르게 실행되는 가에 좌우된다.

   - 동작방식

     1. 실행할 때 컴파일을 하면서 해당 코드를 캐싱한다.

     2. 그 이후에는 바뀐 부분만 컴파일 하고 나머지는 캐싱된 코드를 사용함

     3. JVM은 코드를 바로 컴파일하지 않는다.

        - 컴파일은 한번만 실행되는 프로그램에서는 성능을 발휘하지 못한다. 오히려 인터프리터 보다 느리다. 그럼에도 JIT컴파일러를 사용하는 이유는 하나의 어플리케이션은 여러번 실행되며, 코드는 반복적이기 때문이다.

        - 자주 호출되는 메서드와 루프는 처음 컴파일 시 시간이 오래 걸리겠지만, 다음 번 호출 부터는 그만큼 시간을 절약할 수 있다.

        - 컴파일할 때 시간이 오래걸리기 때문에 자바는  인터프리트된 코드를 실행시킨다.

          ```java
          public class RegisterTest {
          		// sum 변수는 인스턴스 변수이므로 메인메모리에 적제된다.
              private int sum; 
           
              public void calculateSum(int n) {
                	/** 루프를 돌때마다 메인메모리를 참조하는 것은 비효율적인다.
                	* 컴파일러는 sum의 초기값을 레지스터에 로드하고 레지스터 내의 값을 이용하여 푸르를 수행한 뒤, 결과를 메인 메모리에 저장한다.
                	*/
                  for(int i = 0; i < n; i++) {
                      sum += i;
                  }
              }
          }
          ```
          
   
4. 가비지 컬렉터

   - 사용되지 않는 메모리 회수

<br>

>**인터프리터** 
>
>- 코드를 한줄씩 읽고 바로 결과를 출력한다.
>- 같은 코드가 나와도 다시 그 줄을 읽게 된다.
>
>**컴파일러** 
>
>- 한 번만 소스코드를 컴파일하여 같은 기능을 하는 코드가 있으면, 컴파일된 결과를 이용하여 결과를 출력한다.
>
>**코드캐시**
>
>- 컴파일된 코드를 저장하는 곳
>- 코드캐시는 고정적인 크기이며, 가득차면 JVM은 더이상 코드를 컴파알 할 수 없다.
>- ***코드캐시가 부족한 경우?***
>  - 일부 핫스팟만 컴파일되고 다른 영역은 컴파일되지 않는다. 즉, 많은 양의 코드가 인터프리터로 실행되므로 느려진다.



## II. main() 메소드

- 자바 프로그램이 실행되려면 맨 먼저 main() 메소드를 찾아 그 안의 모든 명령문을 차례대로 실행한다.
- 즉, 하나의 자바 프로그램 안에는 main() 메소드를 가지는 클래스가 반드시 하나는 존재해야 한다.

```java
public static void main(String[] args){}
```

- main() 메소드는 반환값이 없으며, 프로그램 내의 모든 전역변수에 접근이 가능해야 하기에 `static`, `void` 키워드를 사용한다.



## III. 변수

- 데이터를 저장하는 메모리 공간
- 값이 변할 수 있음
- JAVA 식별자 규칙
  - 하나 이상의 글자로 이루어져야 함
  - 첫 번째 글자는 문자 이거나 '$', '_'이어야 함
    - 주로 첫 글자는 소문자인 명사를 사용함
    - 복합 단어의 경우 두번째 단어의 첫 글자를 대분자로 사용 : totalCount
  - 두번재 이후의 글자는 숫자, 문자, '$', '_'이어야 함
  - '$', '_' 이외의 특수문자 사용 불가능
  - 길이 제한이 없음
  - 키워드는 식별자로 사용할 수 없음
  - 상수 값을 표현하는 단어 true, false, null은 식별자로 사용할 수 없음



- 변수 초기화

  ```java
  public class Test {
      boolean a;
      
      void test() {
          System.out.println(a);	// false
          
          boolean b;
          System.out.println(b);	// error
      }
  }
  ```
  - 로컬변수는 스택에 올라가므로 컴파일러가 컴파일할때 검증이 가능하므로 오류를 발생시킨다.
  - 전역변수는 힙에 올라가는데, 절차 지향이 아닌 객체지향인 자바에서 힙메로리에 대한 로직을 검증할 수 없으므로 힙메모리에 올라가는 변수들는 자동으로 초기화 한 것
  - 힙에 올라가는 배열, 객체들이 자동 초기화 되는 것도 같은 맥락이다.

## IV. 상수

- 수식에서 변하지 않는 값

- `final` 키워드를 사용한다.

  ```java
  final double PI = 3.14159;
  ```

- 상수 명명 규칙

  - 모두 대문자로 구성된 명사를 사용한다.
  - 복합어의 경우 단어 사이에 '_'를 사용한다.



## V. 기본형 타입

- 기본형 데이터 타입은 가장 기본이 되는 데이터 타입으로써 정수형, 실수형, 문자형, 불린형을 의미한다.

1. 논리형

   | 키워드  | 크기  | 표현 범위   |
   | ------- | ----- | ----------- |
   | Boolean | 1byte | true, false |

2. 문자형

   | 키워드 | 크기  | 표현 범위  |
   | ------ | ----- | ---------- |
   | char   | 2byte | 0 ~65, 535 |

3. 정수형

   - 자바에서는 정수연산을 4byte로 처리한다. 즉, byte type혹은 short타입을 + 연산할 때 int형으로 변환되어 연산이 수행되며, 연산 값 또한 int형이 반환된다.

   | 키워드 | 크기  | 표현 범위        |
   | ------ | ----- | ---------------- |
   | byte   | 1byte | -128 ~ 127       |
   | short  | 2byte | -32,768 ~ 32,767 |
   | char   | 2byte | 0 ~ 2^16         |
   | int    | 4byte | -2^31 ~ 2^31-1   |
   | long   | 8byte | -2^63 ~ 2^63-1   |
   ```java
   long l = 345678991234L;		// 컴파일러에게 데이터 타입이 long 타입임을 알리기 위해 'L' 혹은 'l'을 사용하며, 이를 사용하지 않으면 컴파일에러가 발생한다.
   ```

4. 실수형
  
   - int, long과 같이 각가 4byte, 8byte 이지만, 실수타입에서는 `부동 소수점`을 사용하여 수를 표현한다. 결과적으로 정수 타입보다 더 많은 데이터를 저장할 수 있다.
   - 실수 리터럴의 기본형은 double이므로 float을 사용하기 위해 'F','f' 키워드를 사용해햐한다.
   
   ```java
   float f = 3.14f
   ```
   
   | 키워드 | 크기  | 지수의 길이 | 가수의 길이 | 유효 자릿수    | 표현 범위 |
   | ------ | ----- | ----------- | ----------- | ------------------ | ------ |
   | float  | 4byte | 8비트 | 23비트 | 소수부분 6자리까지 오차없이 표현가능 | -3.4E038 ~ 3.4E038 |
   | double | 8byte | 11비트 | 52비트 | 소수부분 15자리까지 오차없이 표현가능 | -1.7E308 ~ 3.4E308 |
   
   - 숫자 하나는 0 ~ 9 까지이므로 숫자 하나를 이진수로 표현하는데 4비트가 사용된다. 
   
     

## VI. 기본형 타입변환

- 형변환이란, 변수 또는 리터럴의 타입을 다른 타입으로 변환하는 것이다.

```
# 묵시적 형변환 =>
byte형 → short형 → int형 → long형 → float형 → double형
         char형 ↗
# 명시적 형변환 <=
```

1. 묵시적 형변환(자동타입변환)

   - 크기가 작은 타입은 자동으로 크기가 큰 타입으로 변환이 가능하다.

   ```java
   int i = 3;
   double d = i;
   ```

2. 명시적 형변환(강제타입변환)

   - 크기가 더 큰 타입을 작은 타입으로 바꾸기 위해서는 형변환을 명시적으로 해줘야 한다.

   ```java
   double d = 3.0;
   int i = (int) d;
   ```

   

