# 패키지, 접근 제어자, 상속, 오버라이딩

## I. 패키지(package)

- 자바에서 패키지란 클래스와 인터페이스의 집합을 의미한다. 

- 서로 관련있는 클래스나 인터페이스를 함께 묶음으로써 파일을 효율적으로 관리할 수 있게 된다.

- 협업 시, 서로 작업한 클래스 사이에서 발생할 수 있는 이름 충돌 문제도 패키지를 이용하면 피할 수 있다.

- 자바에서 패키지는 물리적으로 하나의 디렉터리를 의미하며, 하나의 패키지는 다른 패키지를 포함할 수 있어, 디렉터리 구조는 계층 구조로 이뤄진다. 또한 이 계층 구조 사이의 구분은 점(.)이다.

  ```java
  // String클래스는 java.lang패키지에 속해있다.
  import java.lang.String
  ```
  
- 패키지 선언은 소스파일의 최상단에 패키지를 명시하면 된다.

  ```java
  package 패키지이름;
  ```

- 자바의 모든 클래스는 반드시 하나 이상의 패키지에 포함되어야 한다. 그러나 소스 파일에 패키지 선언이 포함되어 있지 않는 경우, 컴파일러는 해당 소스파일의 패키지를 '이름 없는 패키지(unnamed package)'에 포함하여 컴파일한다. 즉, 이름을 명시하지 않은 모든 클래스와 인터페이스는 모두 같은 패키지에 포함된다.



### a. import 문

- 다른 패키지에 속한 클래스를 사용하기 위해서는 클래스의 이름 앞에 패키지의 경로까지 포함한 풀네임을 명시해야 한다. 그러나 매번 이렇게 풀네임을 사용하는 것은 비효율적이므로, 자바에서는 import 키워드를 사용한다. import 문을 사용하면 패키지 이름을 제외한 클래스 이름만 사용이 가능하다.

- import 문은 컴파일러에 코드에서 사용할 클래스의 패키지 정보를 미리 제공하는 역할을 한다. 

  ```java
  import java.*	// error
    
  import java.util.* // java.util 패키지 안에 있는 모든 클래스 사용
  ```

- 자바에서 가장 많이 사용되는 java.lang 패키지는 따로 import하지 않아도 클래스 이름만으로 사용이 가능하다.



## II. 접근 제어자

- 객체 지향에서 정보 은닉이란 사용자가 굳이 알 필요 없는 정보는 사용자로부터 숨겨야 한다는 개념이다.

- 접근제어자는 객체지향의 `캡슐화`와 연관되어 있다.

- 접근 제어자의 접근 범위
  
  - public > protected > default > private
  
  > **public :** 접근을 제한 없음
  >
  > **protected :** 동일한 패키지 내에 존재하거나 파생클래스에서만 접근 가능
  >
  > **default :** 아무런 접근 제한자를 명시하지 않으면 default 값이 되며, 동일한 패키지 내에서만 접근이 가능
  >
  > **private :** 자기 자신의 클래스 내에서만 접근이 가능

| 접근 제어자 | 같은 클래스의 멤버 | 같은 패키지의 멤버 | 자식 클래스(외부 패키지) | 외부 패키지 |
| :---------: | :----------------: | :----------------: | :----------------------: | :---------: |
|   public    |         O          |         O          |            O             |      O      |
|  protected  |         O          |         O          |            O             |      X      |
|   default   |         O          |         O          |            X             |      X      |
|   private   |         O          |         X          |            X             |      X      |



## III.  기타 제어자

### a. final 제어자

- 자바에서 `final` 제어자는 '변경할 수 없다'는 의미로 사용된다.
- 즉, 필드나 지역 변수에 상용되며, 값을 변경할 수 없는 `상수` 의 선언에 사용된다.
- 변경이 불가능하므로 클래스에 사용하면, **다른 클래스가 상속받을 수 없게 된다.**
- 메소드에 사용하면, 메소드 오버라이딩을 통한 재정의가 불가능해진다.

```java
final class Car {	// 이 클래스는 상속을 통해 서브 클래스를 생성할 수 없음.
    final int VAR;	// 이 필드는 상수화되어 값을 변경할 수 없음.
    final void brake() {	// 이 메소드는 오버라이딩을 통해 재정의할 수 없음.
        final double MAX_NUM = 10.2;	// 이 지역 변수는 상수화되어 값을 변경할 수 없음.
    }
}
```



### b. static 제어자

- 자바에서 `static` 제어자는 '공통적인'이라는 의미로 사용된다.
- 즉, static 제어자를 클래스 내 변수에 사용하면 해당 변수를 클래스 변수로 만들어 준다.
- 컴파일러가 main()이 실행되기 전에 메모리에 static 멤버들을 적제하므로, 전역 변수의 개념으로 생각하면 이해하기 쉽다.
  - 프로그램 시작시 최초에 단 한 번만 생성되고 초기화된다.
  - 인스턴스를 생성하지 않아도 사용이 가능하다.
  - 해당 클래스의 모든 인스턴스가 공유한다.



### c. abstrat 제어자

- 자바에서 `abstract` 제어자는 '추상적인'이라는 의미로 사용된다.
- 선언부만 존재하고 구현부가 없는 메소드를 추상 메소드라하며, 반드시 abstract 제어자를 붙인다.
- 또한, 하나 이상의 추상 메서드를 가지고 있는 클래스 역시 abstract 제어자를 붙여야 한다.

- 구현부가 없으므로 추상클래스는 다른 클래스에서 상속받아 오버라이딩해야만 사용할 수 있다.



> #### 자바 접근 제어자의 특징
>
> 1. 클래스에 final, abstract는 함께 사용할 수 없다.
>    - final 제어자를 사용한 클래스는 상속이 불가능하므로, 재정의가 필요한 추상클래스(abstract)와는 함께 사용할 수 없다.
> 2. 메소드에 static, abstract는 함께 사용할 수 없다.
>    - 추상메소드(abstract)는 선언부만 있고, 구현부가 없다. static 메소드는 전역에 생성(인스턴스 생성 없이 사용)되므로 같이 사용할 수 없다.
> 3. 메소드에 private, abstract는 함께 사용할 수 없다.
>    - 추상메소드(abstract)는 상속받아 오버라이딩하여 사용해야 하는데, private 메소드는 자식에서 접근이 불가능하다.
> 4. 메소드에 private, final는 함께 사용할 필요가 없다.
>    - final, private 메소드는 모두 오버라이딩이 불가능하다. 둘 중 하나만 사용해도 의미 전달이 가능하다.



## III. 상속

- 상속이란 기존 클래스에 기능을 투가하거나 재정의하여 새로운 클래스를 정의하는 것을 의미한다.

- `상속`은 `캡슐화`,` 추상화` 와 같은 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나이다.

- 상속은 기존에 정의되어 있던 클래스의 모든 필드와 메소드를 물려받아, 새로운 클래스를 생성할 수 있다. 이때, 기존의 클래스를 **부모클래스(parent class)** 혹은 **상위 클래스(super clas)**, **기초 클래스(base class)**라고 한다. 또한, 새롭게 정의된 클래스를 **자식 클래스(child class)**, **하위 클래스(sub class)**, **파생 클래스(derived class)**라고 한다.

- 상속의 장점

  - 기존에 작성된 클래스를 재활용할 수 있다.
  - 자식 클래스 설계 시 중복되는 멤버를 미리 부모 클래스에서 정의해두면, 자식 클래스에서는 해당 멤버를 작성하지 않아도 된다.
  - 클래스 간 계층적 관계를 구성함으로써 `다형성`의 문법적 토대를 마련한다.

  
<div style="text-align:center;border:solid 1px #181818;width:50%;"> 
자식 클래스
  <div style="width:40%;margin:5%;border:solid 1px #181818"> 
    부모 클래스
    <br/>
    <div style="margin:5%;border:solid 1px #181818">
    상속된 멤버
    </div>
  </div>
  <div style="margin:5%;border:solid 1px #181818">
  추가된 멤버
  </div>
</div>
- 부모 클래스는 자식 클래스에 포함된다. 따라서, 부모 클래스에 새로운 필드를 추가하면 모든 자식 클래스에도 동일한 필드가 추가된다.
- **자식 클래스에는 부모 클래스의 필드와 메소드만 상속되며, 생성자와 초기화 블록은 상속되지 않는다.**

- 부모 클래스의 접근 제어자가 private, default로 설정된 멤버는 자식 클래스에서 상속 받지만 접근은 불가능하다.

  ```java
  class Parent{
    private int a = 10;
    public int b = 20;
  }
  class Child extends Parent{
  	public int c = 30;
    void display(){
      System.out.println(a); // error
      System.out.println(b); // 20
      System.out.println(c); // 30
    }
  }
  ```

- 자바에서 클래스는 단 한 개의 클래스만을 상속받는 단일 상속만 가능하다.

>#### Object 클래스
>
>자바에서 Object 클래스는 모든 클래스의 부모가 되는 클래스로, 자바의 클래스들은 자동으로 Object 클래스의 필드와 메서드를 상속받는다.
>
>자바의 모든 객체에서 toString(), clone()과 같은 메소드를 바로 사용할 수 있는 이유이다.



### a. super와 super()

#### super 키워드

- 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조할 때 사용하는 참조 변수
- 부모 클래스와 자식 클래스의 멤버의 이름이 같은 경우, super 키워드로 구분 가능하다.
- this와 마찬가지로 super 참조 변수를 사용할 수 있는 대상도 인스턴스 메소드 뿐이며, 클래스 메소드에서는(대상이 메모리에 올라가지 않았으므로) 사용이 불가능하다.

```java
class Parent{
    int a = 10;
}
class Child extends Parent{
    int a = 20;
    void display(){
        System.out.println(a); // 20
        System.out.println(this.a); // 20
        System.out.println(super.a); // 10
    }
}
```



#### super() 메소드

- 부모 클래스의 생성자를 호출할 때 사용한다.
- 자식 클래스의 인스턴스를 생성하면, 해당 인스턴스에는 부모 클래스의 인스턴스 역시 포함된다. 부모 클래스의 멤버를 초기화하기 위해서는 자식 클래스의 생성자에서 부모 클래스의 생성자를 호출해야 한다.
- **자바의 컴파일러는 부모 클래스의 생성자를 명시적으로 호출하지 않아도 자식 클래스의 생성자 첫 중에 자동으로 super() 메소드를 추가한다.** 그러나 이것도 기본 생성자와 마찬가지로 **부모 클래스의 생성자가 하나라도 정의되어 있지 않은 경우 혹은 기본 생성자까지 명시된 경우**에만 유효하다.

- 즉, 부모 클래스에서 생성자를 하나라도 정의했다면, 기본 생성자도 명시해주거나 자식 생성자에서 부모 클래스의 생성자를 super()를 통해서 초기화해야 한다. 

```java
class Parent{
    int value;

    Parent(){
        this.value = 0;
    }
    Parent(int value){
        this.value = value;
    }
}
class Child extends Parent{
    int value;
		Chile(){
      // 컴파일러가 자동으로 super()를 추가
			this.value = 0;
		}
    Child(int value){
				super(value); // 이 부분이 삭제되면, 컴파일러가 자동으로 super()를 추가
        this.value = value;
    }
}
```



## IV. 메소드 오버라이딩

오버라이딩이란, 상속 관계에 있는 **부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 같은 시그니처를 갖는 메소드로 재정의하는 것**을 말한다.

#### 오버라이딩의 조건

1. 오버라이딩이란 메소드의 동작만을 재정의하는 것으로, 메소드의 선언부는 기존 메소드와 완전이 같아야 한다.
   - 메소드의 반환 타입은 부모 클래스의 반환 타입으로 변환할 수 있는 타입이라면 변경이 가능하다. [참고 : 리턴 타입이 다른 오버라이딩](https://bitsoul.tistory.com/55)

2. 부모 클래스의 메소드보다 접근 제어자를 더 좁은 범위로 변경할 수 없다.
3. 부모 클래스보다 더 큰 범위의 예외를 선언할 수 없다.

```java
class Parent{
    int value = 10;
    void display() { System.out.println("부모 클래스 메소드"); }
}
class Child extends Parent{
    int child = 20;

    void display() { System.out.println("자식 클래스 메소드"); }
}

public class JavaStudy01 {

    public static void main(String[] args){
        Child child = new Child();
        child.display();	// 자식 클래스 메소드
      
        Parent parent = new Parent();
        parent.display();	// 부모 클래스 메소드
      
        // 자식 클래스의 영역 중, 부모 클래스로 부터 상속받은 영역에만 접근이 가능하다.
        Parent parent_child = new Child();
        parent_child.display();	// 자식 클래스 메소드
        System.out.println(parent_child.value);
        System.out.println(parent_child.child); // error
    }
}
```